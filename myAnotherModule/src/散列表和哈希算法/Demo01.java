package 散列表和哈希算法;

/**
 * 散列表 HashTable/哈希表
 *     - 概念：
 *         根据键（Key）直接访问在内存存储位置的数据结构。
 *         key 经过 散列函数 直接映射到内存地址
 *
 * 散列函数/哈希函数  hashValue = hash(key)
 *     - 概念：一个函数，将给定的 key 转换为特定的散列值
 *     - 要求：
 *         1.散列函数计算得到的散列值必须是大于等于0的正整数，因为hash值需要作为数组的下标
 *         2.如果 key1==key2，那么经过 hash 后得到的哈希值也必相同即：hash(key1) == hash(key2)
 *         3.如果 key1 != key2，那么经过 hash 后得到的哈希值也必不相同即：hash(key1) != hash(key2)
 *     - 特点
 *         1.散列函数不能太复杂，因为太复杂度势必要消耗很多的时间在计算哈希值上，也会间接影响散列表性能。
 *         2.散列函数计算得出的哈希值尽可能的能随机并且均匀的分布，这样能够将散列冲突最小化
 *     - 设计方法
 *         1.直接寻址 hash(key) = key  线性函数 hash(key) = a x key + b，其中 a,b 为常量
 *         2.除留余数 hash(key) = key mod p (p≤m), m为散列表长度。当P取小于哈希表长的最大质数时，产生的哈希函数较好
 *         3.平方取中 hash(key) = 取中间几位(key²)
 *         4.折叠法   hash(key) = key.split().sum() 分割成几部分相加
 *     - 散列冲突处理方法
 *         1.开放寻址法，：一旦出现了散列冲突，我们就重新去寻址一个空的散列地址。
 *           当数据量比较小、装载因子小的时候，适合采用开放寻址法。
 *               线性检测 hash(key)+1 ；二次检测 hash(key)+1²；双重检测hash1(key)
 *         2.链表法 适合存储大对象、大数据量的散列表
 *
 * 哈希算法
 *     - 概念：将任意数据通过函数映射到长度固定的数据串 的映射规则
 *     - 要求：
 *         1.任何信息只有唯一的哈希值，原始数据只要有修改，哈希值也会大不相同
 *         2.摘要的长度固定
 *         3.哈希算法是单向的，不可能从摘要反推原始信息
 *         4.哈希算法要尽量高效
 *     - 常用算法：MD5 哈希值是32位16进制数
 *
 * JAVA中的HashMap
 *     java中的HashTable与HashMap都是通过散列表实现（hash表+链表）：
 *     HashMap 与 HashTable 区别：Hashtable是遗留的类 1线程安全；2 key不可以为null
 *     jdk1.8中扩容 1.对红黑树的操作（链表>8树化，红黑树<6退化成链表
 *                  2.优化了在 hash 冲突时计算元素新下标的代码，使其非常简单高效！
 *
 */
public class Demo01 {
}
